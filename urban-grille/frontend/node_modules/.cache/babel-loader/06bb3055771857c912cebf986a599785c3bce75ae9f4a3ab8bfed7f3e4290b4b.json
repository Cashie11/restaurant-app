{"ast":null,"code":"import{useRef,useState,useCallback}from'react';export const useTouchSwipe=totalItems=>{const containerRef=useRef(null);const[currentIndex,setCurrentIndex]=useState(0);const[isDragging,setIsDragging]=useState(false);const[startX,setStartX]=useState(0);const[currentX,setCurrentX]=useState(0);const[cardOffset,setCardOffset]=useState(0);const handleTouchStart=useCallback(e=>{setIsDragging(true);setStartX(e.touches[0].clientX);setCurrentX(e.touches[0].clientX);setCardOffset(0);},[]);const handleTouchMove=useCallback(e=>{if(!isDragging)return;const x=e.touches[0].clientX;setCurrentX(x);const diff=x-startX;setCardOffset(diff);},[isDragging,startX]);const handleTouchEnd=useCallback(()=>{if(!isDragging)return;const diff=currentX-startX;const threshold=100;// Minimum swipe distance\nif(Math.abs(diff)>threshold){// Swipe detected - move to next card\nif(currentIndex<totalItems-1){setCurrentIndex(prev=>prev+1);}}// Reset\nsetIsDragging(false);setCardOffset(0);},[isDragging,currentX,startX,currentIndex,totalItems]);const goToSlide=useCallback(index=>{if(index>=0&&index<totalItems){setCurrentIndex(index);}},[totalItems]);return{currentIndex,isDragging,containerRef,handleTouchStart,handleTouchMove,handleTouchEnd,goToSlide,cardOffset};};","map":{"version":3,"names":["useRef","useState","useCallback","useTouchSwipe","totalItems","containerRef","currentIndex","setCurrentIndex","isDragging","setIsDragging","startX","setStartX","currentX","setCurrentX","cardOffset","setCardOffset","handleTouchStart","e","touches","clientX","handleTouchMove","x","diff","handleTouchEnd","threshold","Math","abs","prev","goToSlide","index"],"sources":["/home/cyber/Desktop/Bot/team1/urban-grille/frontend/src/hooks/useTouchSwipe.ts"],"sourcesContent":["import { useRef, useState, useCallback } from 'react';\n\ninterface SwipeHandlers {\n    handleTouchStart: (e: React.TouchEvent) => void;\n    handleTouchMove: (e: React.TouchEvent) => void;\n    handleTouchEnd: () => void;\n}\n\nexport const useTouchSwipe = (totalItems: number): SwipeHandlers & {\n    currentIndex: number;\n    isDragging: boolean;\n    containerRef: React.RefObject<HTMLDivElement | null>;\n    goToSlide: (index: number) => void;\n    cardOffset: number;\n} => {\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [currentIndex, setCurrentIndex] = useState(0);\n    const [isDragging, setIsDragging] = useState(false);\n    const [startX, setStartX] = useState(0);\n    const [currentX, setCurrentX] = useState(0);\n    const [cardOffset, setCardOffset] = useState(0);\n\n    const handleTouchStart = useCallback((e: React.TouchEvent) => {\n        setIsDragging(true);\n        setStartX(e.touches[0].clientX);\n        setCurrentX(e.touches[0].clientX);\n        setCardOffset(0);\n    }, []);\n\n    const handleTouchMove = useCallback((e: React.TouchEvent) => {\n        if (!isDragging) return;\n        \n        const x = e.touches[0].clientX;\n        setCurrentX(x);\n        const diff = x - startX;\n        setCardOffset(diff);\n    }, [isDragging, startX]);\n\n    const handleTouchEnd = useCallback(() => {\n        if (!isDragging) return;\n        \n        const diff = currentX - startX;\n        const threshold = 100; // Minimum swipe distance\n        \n        if (Math.abs(diff) > threshold) {\n            // Swipe detected - move to next card\n            if (currentIndex < totalItems - 1) {\n                setCurrentIndex(prev => prev + 1);\n            }\n        }\n        \n        // Reset\n        setIsDragging(false);\n        setCardOffset(0);\n    }, [isDragging, currentX, startX, currentIndex, totalItems]);\n\n    const goToSlide = useCallback((index: number) => {\n        if (index >= 0 && index < totalItems) {\n            setCurrentIndex(index);\n        }\n    }, [totalItems]);\n\n    return {\n        currentIndex,\n        isDragging,\n        containerRef,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n        goToSlide,\n        cardOffset\n    };\n};\n"],"mappings":"AAAA,OAASA,MAAM,CAAEC,QAAQ,CAAEC,WAAW,KAAQ,OAAO,CAQrD,MAAO,MAAM,CAAAC,aAAa,CAAIC,UAAkB,EAM3C,CACD,KAAM,CAAAC,YAAY,CAAGL,MAAM,CAAiB,IAAI,CAAC,CACjD,KAAM,CAACM,YAAY,CAAEC,eAAe,CAAC,CAAGN,QAAQ,CAAC,CAAC,CAAC,CACnD,KAAM,CAACO,UAAU,CAAEC,aAAa,CAAC,CAAGR,QAAQ,CAAC,KAAK,CAAC,CACnD,KAAM,CAACS,MAAM,CAAEC,SAAS,CAAC,CAAGV,QAAQ,CAAC,CAAC,CAAC,CACvC,KAAM,CAACW,QAAQ,CAAEC,WAAW,CAAC,CAAGZ,QAAQ,CAAC,CAAC,CAAC,CAC3C,KAAM,CAACa,UAAU,CAAEC,aAAa,CAAC,CAAGd,QAAQ,CAAC,CAAC,CAAC,CAE/C,KAAM,CAAAe,gBAAgB,CAAGd,WAAW,CAAEe,CAAmB,EAAK,CAC1DR,aAAa,CAAC,IAAI,CAAC,CACnBE,SAAS,CAACM,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,CAC/BN,WAAW,CAACI,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,CACjCJ,aAAa,CAAC,CAAC,CAAC,CACpB,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAK,eAAe,CAAGlB,WAAW,CAAEe,CAAmB,EAAK,CACzD,GAAI,CAACT,UAAU,CAAE,OAEjB,KAAM,CAAAa,CAAC,CAAGJ,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAC9BN,WAAW,CAACQ,CAAC,CAAC,CACd,KAAM,CAAAC,IAAI,CAAGD,CAAC,CAAGX,MAAM,CACvBK,aAAa,CAACO,IAAI,CAAC,CACvB,CAAC,CAAE,CAACd,UAAU,CAAEE,MAAM,CAAC,CAAC,CAExB,KAAM,CAAAa,cAAc,CAAGrB,WAAW,CAAC,IAAM,CACrC,GAAI,CAACM,UAAU,CAAE,OAEjB,KAAM,CAAAc,IAAI,CAAGV,QAAQ,CAAGF,MAAM,CAC9B,KAAM,CAAAc,SAAS,CAAG,GAAG,CAAE;AAEvB,GAAIC,IAAI,CAACC,GAAG,CAACJ,IAAI,CAAC,CAAGE,SAAS,CAAE,CAC5B;AACA,GAAIlB,YAAY,CAAGF,UAAU,CAAG,CAAC,CAAE,CAC/BG,eAAe,CAACoB,IAAI,EAAIA,IAAI,CAAG,CAAC,CAAC,CACrC,CACJ,CAEA;AACAlB,aAAa,CAAC,KAAK,CAAC,CACpBM,aAAa,CAAC,CAAC,CAAC,CACpB,CAAC,CAAE,CAACP,UAAU,CAAEI,QAAQ,CAAEF,MAAM,CAAEJ,YAAY,CAAEF,UAAU,CAAC,CAAC,CAE5D,KAAM,CAAAwB,SAAS,CAAG1B,WAAW,CAAE2B,KAAa,EAAK,CAC7C,GAAIA,KAAK,EAAI,CAAC,EAAIA,KAAK,CAAGzB,UAAU,CAAE,CAClCG,eAAe,CAACsB,KAAK,CAAC,CAC1B,CACJ,CAAC,CAAE,CAACzB,UAAU,CAAC,CAAC,CAEhB,MAAO,CACHE,YAAY,CACZE,UAAU,CACVH,YAAY,CACZW,gBAAgB,CAChBI,eAAe,CACfG,cAAc,CACdK,SAAS,CACTd,UACJ,CAAC,CACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}